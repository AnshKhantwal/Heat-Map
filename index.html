<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patient Heatmap Dashboard</title>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            padding: 24px 30px 18px;
            text-align: center;
        }

        .header h1 {
            font-size: 26px;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .header p {
            opacity: 0.95;
            font-size: 13px;
        }

        .controls {
            background: #f8f9fa;
            padding: 20px 28px;
            border-bottom: 1px solid #e9ecef;
        }

        .control-row {
            display: grid;
            grid-template-columns: repeat(6, minmax(0, 1fr));
            gap: 18px;
            align-items: flex-end;
        }

        @media (max-width: 992px) {
            .control-row {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: 600;
            margin-bottom: 6px;
            color: #333;
            font-size: 13px;
        }

        .control-group select,
        .control-group button {
            padding: 10px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.25s ease;
        }

        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.25);
        }

        .control-group button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            border: none;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .control-group button:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.35);
        }

        #map {
            width: 100%;
            height: 600px;
            background: #e9ecef;
            position: relative;
        }

        .info-panel {
            background: #f8f9fa;
            padding: 16px 28px 18px;
            border-top: 1px solid #e9ecef;
            font-size: 13px;
            color: #555;
        }

        .legend {
            background: white;
            padding: 18px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            font-size: 14px;
            position: absolute;
            bottom: 40px;
            right: 25px;
            z-index: 400;
            width: 170px;
        }

        .legend-title {
            font-weight: 700;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        .app-footer {
            text-align: center;
            padding: 18px;
            margin-top: 20px;
            font-size: 13px;
            color: #ffffff;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.25);
        }

        .app-footer strong {
            font-weight: 700;
            color: #ffeaa7;
        }
    </style>
</head>

<body>
<div class="container">
    <div class="header">
        <h1>üìä Patient Distribution Heatmap</h1>
        <p>Live data from Google Sheets</p>
    </div>

    <div class="controls">
        <div class="control-row">
            <div class="control-group">
                <label>Data Type</label>
                <select id="dataType">
                    <option value="doctors">Doctors</option>
                    <option value="patients">Patients</option>
                </select>
            </div>

            <div class="control-group">
                <label>Select Branch</label>
                <select id="branch">
                    <option value="shahdra">Shahdra</option>
                    <option value="keshavpuram">Keshavpuram</option>
                    <option value="mayurvihar">Mayur Vihar</option>
                    <option value="tigri">Tigri</option>
                    <option value="uttamnagar">Uttam Nagar</option>
                </select>
            </div>

            <div class="control-group">
                <label>From Month</label>
                <select id="startMonth">
                    <option value="01">January</option>
                    <option value="02">February</option>
                    <option value="03">March</option>
                    <option value="04">April</option>
                    <option value="05">May</option>
                    <option value="06">June</option>
                    <option value="07">July</option>
                    <option value="08">August</option>
                    <option value="09">September</option>
                    <option value="10">October</option>
                    <option value="11">November</option>
                    <option value="12">December</option>
                </select>
            </div>

            <div class="control-group">
                <label>To Month</label>
                <select id="endMonth">
                    <option value="01">January</option>
                    <option value="02">February</option>
                    <option value="03">March</option>
                    <option value="04">April</option>
                    <option value="05">May</option>
                    <option value="06">June</option>
                    <option value="07">July</option>
                    <option value="08">August</option>
                    <option value="09">September</option>
                    <option value="10">October</option>
                    <option value="11">November</option>
                    <option value="12">December</option>
                </select>
            </div>

            <div class="control-group">
                <label>Select Year</label>
                <select id="year">
                    <option value="2025">2025</option>
                    <option value="2026">2026</option>
                </select>
            </div>

            <div class="control-group">
                <button onclick="generateHeatmap()">üîç Search & Update</button>
            </div>
        </div>
    </div>

    <div id="map"></div>

    <div class="info-panel">
        <strong>Selected:</strong>
        <span id="selection-info">Shahdra - January 2025</span>
        <br>
        <strong>Total Patients:</strong> <span id="patient-count">0</span>
    </div>
</div>

<footer class="app-footer">
    Designed & Developed by <strong>Ansh Khantwal</strong>
</footer>

<script>
/* ================================
   CONFIG
================================ */

const SPREADSHEET_IDS = {
  doctors: "18iugkkdqpBrxaFYTtm3w_pMqRcZr46NtAsMtydsJoDE",
  patients: "1U0JrZjcx8EtngA9RSHErMHSgn9Fn774primy1lhjt5g"
};
const GEOCODING_API_KEY = "AIzaSyDCFngxtr0kabvbfPPUbDSlkv9Z1yFAuMw"; // Leave empty if not using, add key to enable auto-generation

const sheetGIDs = {
  doctors: {
    2025: {
      shahdra: "0",
      keshavpuram: "68749806",
      mayurvihar: "1783876413",
      tigri: "389517366",
      uttamnagar: "1397431706"
    },
    2026: {
      shahdra: "974309338",
      keshavpuram: "1480543339",
      mayurvihar: "441975283",
      tigri: "2117592559",
      uttamnagar: "1079630349"
    }
  },
  patients: {
    2025: {
      shahdra: "0",
      keshavpuram: "614910838",
      mayurvihar: "567704715",
      tigri: "1090498939",
      uttamnagar: "391499502"
    },
    2026: {
      shahdra: "1411998978",
      keshavpuram: "891130830",
      mayurvihar: "1190430256",
      tigri: "1493142650",
      uttamnagar: "1739979788"
    }
  }
};

const branchMarkers = [
  {
    id: "mayurvihar",
    branchName: "Mayur Vihar Branch",
    addressLine: "TB Clinic, DDA Market, F-7, Mayur Vihar Phase I, Pocket 1, Delhi 110091",
    lat: 28.587823577313883,
    lng: 77.29524796030913
  },
  {
    id: "shahdra",
    branchName: "Durgapuri Branch (Shahdara)",
    addressLine: "C-45, West Jyoti Nagar, Durgapuri Extension, Shahdara, Delhi, 110094",
    lat: 28.670281175652055,
    lng: 77.29041017548658
  },
  {
    id: "keshavpuram",
    branchName: "Lawrence Road Branch (Keshavpuram)",
    addressLine: "C-8/139, Lawrence Road Gate No 3, Keshavpuram, Delhi -35",
    lat: 28.690205,
    lng: 77.15582300000001
  },
  {
    id: "tigri",
    branchName: "Tigri Branch",
    addressLine: "A Block 111, 112, 113 Ground floor Bank Road JJ Colony Tigri, New Delhi-110080 (near Sheetla Mata Mandir)",
    lat: 28.51182329848319,
    lng: 77.23747656956373
  },
  {
    id: "uttamnagar",
    branchName: "Uttam Nagar Branch",
    addressLine: "RZ-10, Uttam Nagar, Main Najafgarh Road, Near Pillar No. 713, Next to IDBI Bank, Uttam Nagar",
    lat: 28.620976288266032,
    lng: 77.0488369663347
  }
];

/* ================================
   STATE
================================ */

let coordinates = {};
let generatedCoordinates = { shahdra: {}, keshavpuram: {}, mayurvihar: {}, tigri: {}, uttamnagar: {} };
let map, heatLayer;
let branchLeafletMarkers = [];
let zoomHandler = null; // Track zoom event handler

/* ================================
   LOAD COORDINATES
================================ */

async function loadCoordinates() {
  try {
    const [s, k, m, t, u] = await Promise.all([
      fetch("data/coordinates_shahdra.json").then(r => r.json()).catch(() => ({})),
      fetch("data/coordinates_keshavpuram.json").then(r => r.json()).catch(() => ({})),
      fetch("data/coordinates_mayurvihar.json").then(r => r.json()).catch(() => ({})),
      fetch("data/coordinates_tigri.json").then(r => r.json()).catch(() => ({})),
      fetch("data/coordinates_uttamnagar.json").then(r => r.json()).catch(() => ({}))
    ]);

    coordinates = {
      shahdra: s.shahdra || {},
      keshavpuram: k.keshavpuram || {},
      mayurvihar: m.mayurvihar || {},
      tigri: t.tigri || {},
      uttamnagar: u.uttamnagar || {}
    };
    
    console.log("‚úì Coordinates loaded");
  } catch (err) {
    console.error("Error loading coordinates:", err);
    coordinates = { shahdra: {}, keshavpuram: {}, mayurvihar: {}, tigri: {}, uttamnagar: {} };
  }
}

/* ================================
   GEOCODING (Optional)
================================ */

// Validate if a string looks like a real place/area name suitable for geocoding
function isValidPlaceForGeocoding(name) {
  if (!name || name.trim() === "") return false;
  
  const cleanName = name.trim();
  const upperName = cleanName.toUpperCase();
  
  // Must be at least 3 characters and not too long
  if (cleanName.length < 3 || cleanName.length > 60) return false;
  
  // Skip if it's purely numeric or mostly numbers
  if (/^\d+$/.test(cleanName)) return false;
  const digitCount = (cleanName.match(/\d/g) || []).length;
  if (digitCount / cleanName.length > 0.4) return false;
  
  // Skip phone numbers (various formats)
  if (/^\+?\d[\d\s\-()]{8,}$/.test(cleanName.replace(/\s/g, ""))) return false;
  
  // Skip email addresses
  if (/@/.test(cleanName)) return false;
  
  // Skip URLs
  if (/^(http|www\.|\.com|\.in|\.org)/i.test(cleanName)) return false;
  
  // Skip Excel/spreadsheet errors
  if (/^#(VALUE|REF|N\/A|ERROR|DIV|NAME|NULL)/.test(upperName)) return false;
  
  // Skip common invalid/placeholder entries
  const invalidEntries = [
    "OTHER", "OTHERS", "WOM", "SELF", "DONE", "NONE", "NIL", "NULL", "NA", "N/A",
    "TEST", "DEMO", "SAMPLE", "UNKNOWN", "NOT AVAILABLE", "NOT KNOWN", "PENDING",
    "YES", "NO", "OK", "OKAY", "FINE", "GOOD", "BAD", "NEW", "OLD",
    "TEAM GOOGLE", "GOOGLE", "FACEBOOK", "INSTAGRAM", "WHATSAPP", "JUSTDIAL", "PRACTO",
    "REFERENCE", "REFERRED", "REFERRAL", "WALK IN", "WALKIN", "WALK-IN", "FOLLOWUP",
    "ONLINE", "OFFLINE", "CALL", "CALLING", "CAMP", "OPD", "IPD", "EMERGENCY",
    "CASH", "CARD", "UPI", "PAYMENT", "PAID", "UNPAID", "FREE", "DISCOUNT",
    "MORNING", "EVENING", "NIGHT", "TODAY", "TOMORROW", "YESTERDAY",
    "DONE SUGAR", "SUGAR", "BP", "DIABETES", "THYROID", "FEVER", "COLD", "COUGH"
  ];
  if (invalidEntries.includes(upperName)) return false;
  
  // Skip common person name patterns (titles followed by names)
  const nameTitles = /^(MR\.?|MRS\.?|MS\.?|MISS|DR\.?|SHRI|SMT\.?|KUMARI?|MASTER)\s+/i;
  if (nameTitles.test(cleanName)) return false;
  
  // Skip if it looks like a full person name (common Indian surnames)
  const commonSurnames = [
    "KUMAR", "SHARMA", "SINGH", "GUPTA", "VERMA", "YADAV", "CHAUHAN", "JAIN",
    "AGARWAL", "AGGARWAL", "BANSAL", "GARG", "MALIK", "CHAUDHARY", "CHOWDHURY",
    "PANDEY", "MISHRA", "DUBEY", "TIWARI", "SRIVASTAVA", "SAXENA", "KHANNA",
    "KAPOOR", "ARORA", "BHATIA", "MEHTA", "SETHI", "KOHLI", "MALHOTRA", "CHOPRA",
    "KAUR", "DEVI", "BEGUM", "BIBI", "KHATUN", "BANO", "PARVEEN", "ANJUM"
  ];
  // If it ends with a common surname and has a first name, it's likely a person
  const words = upperName.split(/\s+/);
  if (words.length >= 2) {
    const lastName = words[words.length - 1];
    if (commonSurnames.includes(lastName)) return false;
  }
  // Single word that is a common surname
  if (words.length === 1 && commonSurnames.includes(upperName)) return false;
  
  // Skip common first names that might appear alone or in combinations
  const commonFirstNames = [
    // Male names
    "RAHUL", "AMIT", "SUNIL", "ANIL", "VIJAY", "SANJAY", "RAJESH", "MUKESH",
    "RAM", "SHYAM", "MOHAN", "ROHAN", "SOHAN", "RAVI", "SONU", "MONU", "PINTU",
    "ARUN", "VARUN", "TARUN", "KARAN", "ARJUN", "NITIN", "SACHIN", "HITESH",
    "RAKESH", "MAHESH", "SURESH", "RAMESH", "DINESH", "GANESH", "NARESH",
    "AJAY", "VINAY", "SANJAY", "AKSHAY", "UDAY", "VIJAY", "JAY", "ABHAY",
    "DEEPAK", "ASHOK", "ALOK", "VIVEK", "ANURAG", "GAURAV", "SOURAV", "PANKAJ",
    "MANISH", "DANISH", "ASHISH", "SATISH", "RITESH", "JITESH", "PARESH",
    "VISHAL", "KUSHAL", "SAGAR", "NEERAJ", "MANOJ", "ANUJ", "TANUJ",
    "FAISAL", "SHAHZAD", "SHAHZED", "IMRAN", "IRFAN", "SALMAN", "AAMIR", "AMIR",
    "FARHAN", "REHAN", "ZEESHAN", "SHAHNAWAZ", "SHUAIB", "SHOAIB", "WASIM", "ASIF",
    "NADEEM", "NASEEM", "RASHID", "KHALID", "HAMID", "MAJID", "SAJID", "WAHID",
    "MOHD", "MD", "SHEIKH", "SHAIKH",
    "MOHAMMAD", "MOHAMMED", "KHAN", "AHMED", "ALI", "HUSSAIN", "AKBAR",
    "RAHIS", "RAIS", "ADESH", "UMESH", "LOKESH", "YOGESH",
    // Female names
    "PRIYA", "NEHA", "POOJA", "ANJALI", "SUNITA", "GEETA", "REENA", "MEENA",
    "NISHA", "ASHA", "USHA", "REKHA", "SUDHA", "RADHA", "SHOBHA", "PRABHA",
    "ANITA", "KAVITA", "SAVITA", "LALITA", "MAMTA", "NAMITA", "BABITA", "SUJATA",
    "SEEMA", "REEMA", "NEELAM", "POONAM", "SONAM", "SANAM", "ANAM",
    "NARGIS", "GULAFSHA", "NAZMA", "SHABANA", "RUKHSAR", "SHANEY", "RUBINA",
    "FATIMA", "AYESHA", "SADIA", "NADIA", "ZARA", "SANA", "HINA", "DIYA",
    "PUSHPA", "CHAMPA", "KAMLA", "VIMLA", "SHANTI", "LAXMI", "DURGA",
    "BHAWNA", "SAPNA", "SWAPNA", "ARCHANA", "VANDANA", "SADHANA", "RACHNA",
    "RITU", "PINKY", "RINKU", "MINTU", "GUDDI", "MUNNI", "BITTU", "CHINTU"
  ];
  // Check if any word is a common first name
  if (words.some(word => commonFirstNames.includes(word))) return false;
  if (commonFirstNames.includes(upperName)) return false;
  
  // Skip doctor/hospital references that aren't places
  if (/^DR\s|DOCTOR|HOSPITAL|CLINIC|NURSING|DISPENSARY|CHEMIST|PHARMACY/i.test(cleanName)) return false;
  
  // Skip relationship terms
  const relationships = ["FATHER", "MOTHER", "BROTHER", "SISTER", "SON", "DAUGHTER", "WIFE", "HUSBAND", "UNCLE", "AUNT"];
  if (relationships.includes(upperName)) return false;
  
  // Must contain at least one letter
  if (!/[a-zA-Z]/.test(cleanName)) return false;
  
  // Good indicators that it's a place name
  const placeIndicators = [
    "NAGAR", "PURAM", "PURI", "VIHAR", "COLONY", "ENCLAVE", "EXTENSION", "EXT",
    "SECTOR", "BLOCK", "PHASE", "PARK", "GARDEN", "BAGH", "GANJ", "MARKET",
    "ROAD", "MARG", "STREET", "LANE", "GALI", "CHOWK", "CROSSING",
    "VILLAGE", "GAON", "PUR", "ABAD", "GARH", "KOTHI", "MOHALLA",
    "EAST", "WEST", "NORTH", "SOUTH", "CENTRAL",
    "DELHI", "NOIDA", "GURGAON", "GURUGRAM", "FARIDABAD", "GHAZIABAD"
  ];
  
  // If contains place indicators, it's likely valid
  if (placeIndicators.some(indicator => upperName.includes(indicator))) return true;
  
  // Known Delhi/NCR area names that don't have standard suffixes
  const knownAreas = [
    "SHAHDARA", "SHAHDRA", "LAXMI", "GANDHI", "NEHRU", "TILAK",
    "KAROL BAGH", "CHANDNI CHOWK", "CONNAUGHT", "KASHMERE GATE", "CIVIL LINES",
    "ROHINI", "PITAMPURA", "SHALIMAR", "ASHOK", "PREET", "JANAKPURI", "DWARKA",
    "SAKET", "VASANT", "HAUZ KHAS", "MALVIYA", "SAROJINI", "LAJPAT",
    "OKHLA", "JASOLA", "KALINDI", "MAYUR", "PATPARGANJ", "ANAND",
    "SHAKARPUR", "LAKSHMI", "GEETA", "KRISHNA", "YAMUNA", "WELCOME",
    "SEEMAPURI", "DILSHAD", "JHILMIL", "VIVEK", "HARSH", "MANDOLI",
    "BHAJANPURA", "MAUJPUR", "GOKULPURI", "MUSTAFABAD", "KARAWAL",
    "BURARI", "MUKHERJEE", "NARELA", "BAWANA", "TIMARPUR", "KAMLA",
    "USMANPUR", "USMAAN", "BRAHMPURI", "BHARAMPURI", "GHONDA", "KHODA",
    "BHAGIRATHI", "KABUTAR", "TUKHMIRPUR", "KHAJOORI", "BABARPUR"
  ];
  
  // Check if it matches known areas
  if (knownAreas.some(area => upperName.includes(area))) return true;
  
  // Skip common action/status words that might slip through
  const actionWords = [
    "RESTART", "START", "STOP", "DONE", "COMPLETE", "PENDING", "WAITING",
    "SUGAR", "BLOOD", "TEST", "REPORT", "RESULT", "CHECK", "FOLLOW",
    "NOT DONE", "SUGAR NOT DONE", "BP NOT DONE", "NOT AVAILABLE"
  ];
  if (actionWords.some(word => upperName.includes(word))) return false;
  
  // For entries with numbers, only allow if they look like addresses (sector, block, phase, etc.)
  if (/\d/.test(cleanName)) {
    // Must have location keywords with numbers
    if (/SECTOR|BLOCK|PHASE|POCKET|PLOT|FLAT|HOUSE|NO\.|NUMBER/i.test(cleanName)) return true;
    // Otherwise reject - could be phone fragments, IDs, etc.
    return false;
  }
  
  // Two-word entries without place indicators are likely person names - reject
  // (e.g., "rahis ahmad", "pushpa rani", "shaney zehra")
  if (words.length === 2) {
    // Only allow if one word is very short (like directional: E, W, N, S) or a number
    if (words[0].length <= 2 || words[1].length <= 2) return true;
    return false;
  }
  
  // Three+ word entries might be addresses - be more lenient
  if (words.length >= 3) return true;
  
  // Single words without place indicators - reject by default
  // Too risky as they could be names, abbreviations, or random words
  return false;
}

async function getCoordinatesFromGeocoding(areaName, branch) {
  if (!GEOCODING_API_KEY || GEOCODING_API_KEY === "") {
    return null;
  }

  // Validate before making API call
  if (!isValidPlaceForGeocoding(areaName)) {
    console.log(`‚äò Skipped geocoding (not a valid place): "${areaName}"`);
    return null;
  }

  try {
    const query = `${areaName}, Delhi, India`;
    const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(query)}&key=${GEOCODING_API_KEY}`;
    
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.results && data.results.length > 0) {
      const location = data.results[0].geometry.location;
      
      // Validate that the result is within reasonable bounds for Delhi NCR region
      // Delhi NCR approximate bounds: Lat 28.0-29.0, Lng 76.5-77.8
      if (location.lat < 27.5 || location.lat > 29.5 || location.lng < 76.0 || location.lng > 78.5) {
        console.log(`‚äò Skipped geocoding (outside Delhi NCR): "${areaName}" -> ${location.lat}, ${location.lng}`);
        return null;
      }
      
      const coords = {
        lat: location.lat,
        lng: location.lng
      };
      
      generatedCoordinates[branch][areaName] = coords;
      console.log(`‚úì Auto-generated: ${areaName} -> ${coords.lat.toFixed(6)}, ${coords.lng.toFixed(6)}`);
      return coords;
    }
  } catch (err) {
    console.error(`Geocoding failed for "${areaName}":`, err);
  }
  return null;
}

function exportGeneratedCoordinates(branch) {
  if (Object.keys(generatedCoordinates[branch]).length === 0) {
    alert(`No generated coordinates for ${branch}`);
    return;
  }

  const data = {};
  data[branch] = generatedCoordinates[branch];
  const json = JSON.stringify(data, null, 2);
  
  navigator.clipboard.writeText(json).then(() => {
    alert(`Copied ${Object.keys(generatedCoordinates[branch]).length} coords to clipboard!`);
  });
}

/* ================================
   CSV PARSER
================================ */

function parseCSV(text) {
  const lines = text.trim().split("\n").map(l => l.trim()).filter(l => l);
  
  if (lines.length < 2) {
    console.warn("CSV empty");
    return {};
  }

  const header = lines[0].split(",").map(h => h.trim().toUpperCase());
  
  const monthMap = {
    "JANUARY": "JAN", "FEBRUARY": "FEB", "MARCH": "MAR",
    "APRIL": "APR", "MAY": "MAY", "JUNE": "JUN",
    "JULY": "JUL", "AUGUST": "AUG", "SEPTEMBER": "SEP",
    "OCTOBER": "OCT", "NOVEMBER": "NOV", "DECEMBER": "DEC"
  };
  
  const result = {};
  header.forEach(h => {
    const monthKey = monthMap[h] || h;
    result[monthKey] = [];
  });

  // Function to validate if a string is a valid area name
  function isValidAreaName(name) {
    if (!name || name.trim() === "") return false;
    
    const upperName = name.toUpperCase().trim();
    
    // List of invalid entries to skip
    const invalidEntries = [
      "OTHER", "WOM", "SELF", "DONE", "DONE SUGAR", "TEAM GOOGLE", 
      "#VALUE!", "#REF!", "#N/A", "#ERROR!", "#DIV/0!", "#NAME?",
      "NA", "N/A", "NIL", "NONE", "NULL", "-", "--", "---",
      "TEST", "DEMO", "SAMPLE", "UNKNOWN", "NOT AVAILABLE"
    ];
    
    if (invalidEntries.includes(upperName)) return false;
    
    // Skip if it contains phone number patterns (10+ digits or starts with +)
    if (/^\+?\d{10,}$/.test(name.replace(/[\s\-()]/g, ""))) return false;
    if (/^\d{10,}$/.test(name.replace(/\D/g, ""))) return false;
    
    // Skip if it starts with # (Excel errors)
    if (name.startsWith("#")) return false;
    
    // Skip if it's mostly numbers (likely phone or ID)
    const digitCount = (name.match(/\d/g) || []).length;
    if (digitCount > 5 && digitCount / name.length > 0.5) return false;
    
    // Skip if it's too short (less than 2 characters) or too long (likely a sentence/note)
    if (name.length < 2 || name.length > 50) return false;
    
    // Skip common non-location words that might appear
    const skipWords = [
      "GOOGLE", "FACEBOOK", "INSTAGRAM", "WHATSAPP", "JUSTDIAL", "PRACTO",
      "REFERENCE", "REFERRED", "REFERRAL", "WALK IN", "WALKIN", "WALK-IN",
      "ONLINE", "OFFLINE", "CALL", "CALLING", "CAMP", "OPD", "IPD"
    ];
    if (skipWords.some(word => upperName === word)) return false;
    
    // Skip if it looks like a person's name pattern (common titles)
    if (/^(MR|MRS|MS|DR|SHRI|SMT|KUMAR|SHARMA|SINGH|GUPTA|VERMA)\s/i.test(name)) return false;
    
    return true;
  }

  lines.slice(1).forEach(row => {
    // Don't filter out empty columns - preserve column positions!
    const cols = row.split(",").map(c => c.trim());
    cols.forEach((areaName, colIdx) => {
      if (areaName && isValidAreaName(areaName)) {
        const monthKeys = Object.keys(result);
        if (colIdx < monthKeys.length) {
          result[monthKeys[colIdx]].push(areaName);
        }
      }
    });
  });

  return result;
}

async function loadBranchCSV(branch, year, dataType) {
  try {
    const gid = sheetGIDs[dataType]?.[year]?.[branch];
    if (!gid) {
      console.error(`Missing GID for ${dataType} ${branch} ${year}`);
      return {};
    }

    const spreadsheetId = SPREADSHEET_IDS[dataType];
    const url = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=${gid}`;
    const response = await fetch(url);
    
    if (!response.ok) {
      console.error(`HTTP ${response.status}`);
      return {};
    }
    
    const text = await response.text();
    return parseCSV(text);
  } catch (err) {
    console.error(`Error loading CSV:`, err);
    return {};
  }
}

/* ================================
   FUZZY MATCHING
================================ */

function normalize(str) {
  return str.toLowerCase().replace(/[^a-z0-9 ]/g, "").replace(/\s+/g, " ").trim();
}

function buildLookup(coordObj) {
  const lookup = {};
  for (const key in coordObj) {
    lookup[normalize(key)] = coordObj[key];
  }
  return lookup;
}

function levenshtein(a, b) {
  const m = a.length, n = b.length;
  const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));

  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;

  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      dp[i][j] = Math.min(
        dp[i - 1][j] + 1,
        dp[i][j - 1] + 1,
        dp[i - 1][j - 1] + (a[i - 1] === b[j - 1] ? 0 : 1)
      );
    }
  }
  return dp[m][n];
}

function advancedFuzzyMatch(area, lookup) {
  const areaNorm = normalize(area);
  const tokens = areaNorm.split(" ");

  let bestKey = null;
  let bestScore = Infinity;

  for (const key in lookup) {
    const keyTokens = key.split(" ");
    let totalScore = 0;

    tokens.forEach(t1 => {
      let minScore = Infinity;
      keyTokens.forEach(t2 => {
        const dist = levenshtein(t1, t2);
        if (dist < minScore) minScore = dist;
      });
      totalScore += minScore;
    });

    totalScore = totalScore / tokens.length;

    if (totalScore < bestScore) {
      bestScore = totalScore;
      bestKey = key;
    }
  }

  return bestScore <= 2.5 ? bestKey : null;
}

/* ================================
   MAP
================================ */

function initMap() {
  map = L.map("map").setView([28.6139, 77.2090], 11);

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    opacity: 0.55
  }).addTo(map);

  const legend = L.control({ position: "bottomright" });
  legend.onAdd = function () {
    const div = L.DomUtil.create("div", "legend");
    div.innerHTML = `
      <div class="legend-title">Patient Density</div>
      <div class="legend-item"><div class="legend-color" style="background:#1a9850"></div> Low</div>
      <div class="legend-item"><div class="legend-color" style="background:#66bd63"></div> Medium</div>
      <div class="legend-item"><div class="legend-color" style="background:#fee08b"></div> High</div>
      <div class="legend-item"><div class="legend-color" style="background:#fc8d59"></div> Very High</div>
      <div class="legend-item"><div class="legend-color" style="background:#d73027"></div> Critical</div>
    `;
    return div;
  };
  legend.addTo(map);

  addBranchMarkers();
}

function addBranchMarkers() {
  const icon = L.icon({
    iconUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png",
    iconRetinaUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon-2x.png",
    shadowUrl: "https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png",
    iconSize: [25, 41],
    iconAnchor: [12, 41],
    popupAnchor: [1, -34],
    shadowSize: [41, 41]
  });

  branchMarkers.forEach(b => {
    const marker = L.marker([b.lat, b.lng], { icon });
    marker.bindPopup(`<b>${b.branchName}</b><br>${b.addressLine}`);
    branchLeafletMarkers.push({ id: b.id, marker });
  });
}

function updateBranchMarkers(selectedId) {
  branchLeafletMarkers.forEach(bm => {
    if (bm.id === selectedId) {
      if (!map.hasLayer(bm.marker)) bm.marker.addTo(map);
    } else {
      if (map.hasLayer(bm.marker)) map.removeLayer(bm.marker);
    }
  });
}

/* ================================
   MAIN HEATMAP GENERATOR
================================ */

async function generateHeatmap() {
  const branch = document.getElementById("branch").value;
  const dataType = document.getElementById("dataType").value;
  const start = Number(document.getElementById("startMonth").value);
  const end = Number(document.getElementById("endMonth").value);
  const year = document.getElementById("year").value;

  try {
    const sheet = await loadBranchCSV(branch, year, dataType);
    const lookup = buildLookup(coordinates[branch]);
    
    const monthNames = ["JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC"];
    const heatPoints = [];
    const locationCount = {}; // Track frequency per location
    let totalPatients = 0;

    for (let m = start; m <= end; m++) {
      const month = monthNames[m - 1];
      const areas = sheet[month] || [];

      for (const area of areas) {
        const norm = normalize(area);
        let entry = lookup[norm];

        if (!entry) {
          const best = advancedFuzzyMatch(area, lookup);
          if (best) entry = lookup[best];
        }

        // Try geocoding if not found in JSON
        if (!entry) {
          if (generatedCoordinates[branch][area]) {
            entry = generatedCoordinates[branch][area];
          } else if (GEOCODING_API_KEY && GEOCODING_API_KEY !== "") {
            entry = await getCoordinatesFromGeocoding(area, branch);
          }
        }

        if (entry) {
          // Track frequency per location for intensity
          const locKey = `${entry.lat.toFixed(5)},${entry.lng.toFixed(5)}`;
          locationCount[locKey] = (locationCount[locKey] || 0) + 1;
          totalPatients++;
        }
      }
    }

    // Convert location counts to heat points with intensity based on frequency
    const maxCount = Math.max(...Object.values(locationCount), 1);
    for (const [locKey, count] of Object.entries(locationCount)) {
      const [lat, lng] = locKey.split(",").map(Number);
      // Intensity scaled by frequency (0.3 to 1.0 range)
      const intensity = 0.3 + (count / maxCount) * 0.7;
      heatPoints.push([lat, lng, intensity]);
    }

    const branchInfo = branchMarkers.find(b => b.id === branch);
    const startLabel = document.getElementById("startMonth").selectedOptions[0].text;
    const endLabel = document.getElementById("endMonth").selectedOptions[0].text;
    const dataTypeLabel = document.getElementById("dataType").selectedOptions[0].text;

    document.getElementById("selection-info").textContent =
      `${branchInfo.branchName} ‚Äî ${dataTypeLabel} ‚Äî ${startLabel} to ${endLabel} ${year}`;

    if (heatLayer) map.removeLayer(heatLayer);
    
    // Remove previous zoom handler to avoid duplicates
    if (zoomHandler) {
      map.off('zoomend', zoomHandler);
      zoomHandler = null;
    }

    if (heatPoints.length > 0) {
      // Dynamic radius based on zoom level for precision
      const getRadiusForZoom = (zoom) => {
        if (zoom >= 16) return 15;
        if (zoom >= 14) return 20;
        if (zoom >= 12) return 25;
        if (zoom >= 10) return 30;
        return 35;
      };

      const getBlurForZoom = (zoom) => {
        if (zoom >= 16) return 10;
        if (zoom >= 14) return 12;
        if (zoom >= 12) return 15;
        return 18;
      };

      const currentZoom = map.getZoom();
      
      heatLayer = L.heatLayer(heatPoints, {
        radius: getRadiusForZoom(currentZoom),
        blur: getBlurForZoom(currentZoom),
        maxZoom: 17,
        max: 1.0,
        minOpacity: 0.4,
        gradient: {
          0.0: "#1a9850",
          0.25: "#66bd63",
          0.5: "#fee08b",
          0.75: "#fc8d59",
          1.0: "#d73027"
        }
      }).addTo(map);

      // Update heatmap radius/blur on zoom change for precision
      zoomHandler = function() {
        if (heatLayer) {
          const zoom = map.getZoom();
          heatLayer.setOptions({
            radius: getRadiusForZoom(zoom),
            blur: getBlurForZoom(zoom)
          });
        }
      };
      map.on('zoomend', zoomHandler);

      const bounds = L.latLngBounds([]);
      heatPoints.forEach(p => bounds.extend([p[0], p[1]]));
      const selectedMarker = branchLeafletMarkers.find(bm => bm.id === branch);
      if (selectedMarker) bounds.extend(selectedMarker.marker.getLatLng());
      if (bounds.isValid()) {
        map.fitBounds(bounds.pad(0.25));
      }
    } else {
      const selectedMarker = branchLeafletMarkers.find(bm => bm.id === branch);
      if (selectedMarker) {
        map.setView(selectedMarker.marker.getLatLng(), 13);
      }
    }

    document.getElementById("patient-count").textContent = totalPatients;
    console.log(`‚úì ${branch} ${year} (${dataType}): ${totalPatients} records`);

    updateBranchMarkers(branch);

  } catch (err) {
    console.error("Error:", err);
  }
}

/* ================================
   INIT
================================ */

window.onload = async () => {
  initMap();
  await loadCoordinates();
  document.getElementById("branch").value = "shahdra";
  document.getElementById("startMonth").value = "01";
  document.getElementById("endMonth").value = "01";
  document.getElementById("year").value = "2025";
  
  await generateHeatmap();
};

window.onbeforeunload = () => {};
</script>
</body>
</html>